{"version":3,"file":"iro-core.js","sources":["../src/color.ts","../src/slider.ts","../src/wheel.ts","../src/svg.ts","../src/colorPickerOptions.ts"],"sourcesContent":["// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor\n// https://github.com/bgrins/TinyColor\n\n// https://www.w3.org/TR/css3-values/#integers\nconst CSS_INTEGER = `[-\\\\+]?\\\\d+%?`;\n// http://www.w3.org/TR/css3-values/#number-value\nconst CSS_NUMBER = `[-\\\\+]?\\\\d*\\\\.\\\\d+%?`;\n// Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome\nconst CSS_UNIT = `(?:${ CSS_NUMBER })|(?:${ CSS_INTEGER })`;\n\n// Parse function params\n// Parens and commas are optional, and this also allows for whitespace between numbers\nconst PERMISSIVE_MATCH_3 = `[\\\\s|\\\\(]+(${ CSS_UNIT })[,|\\\\s]+(${ CSS_UNIT })[,|\\\\s]+(${ CSS_UNIT })\\\\s*\\\\)?`;\nconst PERMISSIVE_MATCH_4 = `[\\\\s|\\\\(]+(${ CSS_UNIT })[,|\\\\s]+(${ CSS_UNIT })[,|\\\\s]+(${ CSS_UNIT })[,|\\\\s]+(${ CSS_UNIT })\\\\s*\\\\)?`;\n\n// Regex patterns for functional colors\nconst REGEX_FUNCTIONAL_RGB = new RegExp(`rgb${ PERMISSIVE_MATCH_3 }`);\nconst REGEX_FUNCTIONAL_RGBA = new RegExp(`rgba${ PERMISSIVE_MATCH_4 }`);\nconst REGEX_FUNCTIONAL_HSL = new RegExp(`hsl${ PERMISSIVE_MATCH_3 }`);\nconst REGEX_FUNCTIONAL_HSLA = new RegExp(`hsla${ PERMISSIVE_MATCH_4 }`);\n\nconst HEX_START = `^(?:#?|0x?)`;\nconst HEX_INT_SINGLE = `([0-9a-fA-F]{1})`;\nconst HEX_INT_DOUBLE = `([0-9a-fA-F]{2})`;\nconst REGEX_HEX_3 = new RegExp(`${ HEX_START }${ HEX_INT_SINGLE }${ HEX_INT_SINGLE }${ HEX_INT_SINGLE }$`);\nconst REGEX_HEX_4 = new RegExp(`${ HEX_START }${ HEX_INT_SINGLE }${ HEX_INT_SINGLE }${ HEX_INT_SINGLE }${ HEX_INT_SINGLE }$`);\nconst REGEX_HEX_6 = new RegExp(`${ HEX_START }${ HEX_INT_DOUBLE }${ HEX_INT_DOUBLE }${ HEX_INT_DOUBLE }$`);\nconst REGEX_HEX_8 = new RegExp(`${ HEX_START }${ HEX_INT_DOUBLE }${ HEX_INT_DOUBLE }${ HEX_INT_DOUBLE }${ HEX_INT_DOUBLE }$`);\n\n/**\n * Parse a css unit string - either regular int or a percentage number\n */\nfunction parseUnit(str: string, max: number): number {\n  const isPercentage = str.indexOf('%') > -1;\n  const num = parseFloat(str);\n  return isPercentage ? (max / 100) * num : num;\n}\n\n/**\n * Parse hex str to an int\n */\nfunction parseHexInt(str: string): number {\n  return parseInt(str, 16);\n}\n\n/**\n * Convert into to 2-digit hex\n */\nfunction intToHex(int: number): string {\n  return int.toString(16).padStart(2, '0');\n}\n\ninterface ColorChanges {\n  h: boolean;\n  s: boolean;\n  v: boolean;\n  a?: boolean;\n}\n\ninterface HsvColor {\n  h: number;\n  s: number;\n  v: number;\n  a?: number;\n}\n\ninterface RgbColor {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\ninterface HslColor {\n  h: number;\n  s: number;\n  l: number;\n  a?: number;\n}\n\nexport type IroColorValue = IroColor | HsvColor | RgbColor | HslColor | string;\n\nexport class IroColor {\n  public onChange: Function;\n  public value: HsvColor;\n  /**\n    * @constructor Color object\n    * @param {Object | String | IroColor} value - Color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)\n  */\n  constructor(value?: IroColorValue, onChange?: Function) {\n    // The default Color value\n    this.value = {h: 0, s: 0, v: 0, a: 1};\n    if (value) this.set(value);\n    // The watch callback function for this Color will be stored here\n    this.onChange = onChange;\n  }\n\n  /**\n    * @desc set the Color from any valid value\n    * @param {Object | String | IroColor} value - Color instance, object (hsv, hsl or rgb), string (hsl, rgb, hex)\n  */\n  public set(value: IroColorValue) {\n    const isString = typeof value === 'string';\n    const isObject = typeof value === 'object';\n    if (typeof value === 'string' && (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value as string))) {\n      this.hexString = value as string;\n    }\n    else if (typeof value === 'string' && (/^rgba?/.test(value as string))) {\n      this.rgbString = value as string;\n    }\n    else if (typeof value === 'string' && (/^hsla?/.test(value as string))) {\n      this.hslString = value as string;\n    }\n    else if (typeof value === 'object' && (value instanceof IroColor)) {\n      this.hsv = value.hsv;\n    }\n    else if (typeof value === 'object' && ('r' in value) && ('g' in value) && ('b' in value)) {\n      this.rgb = value;\n    }\n    else if (typeof value === 'object' && ('h' in value) && ('s' in value) && ('v' in value)) {\n      this.hsv = value;\n    }\n    else if (typeof value === 'object' && ('h' in value) && ('s' in value) && ('l' in value)) {\n      this.hsl = value;\n    }\n    else {\n      throw new Error('invalid color value');\n    }\n  }\n\n  /**\n    * @desc shortcut to set a specific channel value\n    * @param {String} format - hsv | hsl | rgb\n    * @param {String} channel - individual channel to set, for example if model = hsl, chanel = h | s | l\n    * @param {Number} value - new value for the channel\n  */\n  public setChannel(format: string, channel: string, value: number) {\n    this[format] = {...this[format], [channel]: value};\n  }\n\n  /**\n    * @desc make new Color instance with the same value as this one\n    * @return {IroColor}\n  */\n  public clone() {\n    return new IroColor(this);\n  }\n\n  /**\n    * @desc convert hsv object to rgb\n    * @param {Object} hsv hsv object\n    * @return {Object} rgb object\n  */\n  public static hsvToRgb(hsv: HsvColor): RgbColor {\n    const h = hsv.h / 60;\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const i = Math.floor(h);\n    const f = h - i;\n    const p = v * (1 - s);\n    const q = v * (1 - f * s);\n    const t = v * (1 - (1 - f) * s);\n    const mod = i % 6;\n    const r = [v, q, p, p, t, v][mod];\n    const g = [t, v, v, q, p, p][mod];\n    const b = [p, p, t, v, v, q][mod];\n    return {\n      r: r * 255, \n      g: g * 255, \n      b: b * 255\n    };\n  }\n\n  /**\n    * @desc convert rgb object to hsv\n    * @param {Object} rgb - rgb object\n    * @return {Object} hsv object\n  */\n  public static rgbToHsv(rgb: RgbColor): HsvColor {\n    const r = rgb.r / 255;\n    const g = rgb.g / 255;\n    const b = rgb.b / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const delta = max - min;\n    let hue = 0;\n    let value = max;\n    let saturation = max === 0 ? 0 : delta / max;\n    switch (max) {\n      case min: \n        hue = 0; // achromatic\n        break;\n      case r: \n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g: \n        hue = (b - r) / delta + 2;\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n    return {\n      h: hue * 60,\n      s: saturation * 100,\n      v: value * 100\n    }\n  }\n\n  /**\n    * @desc convert hsv object to hsl\n    * @param {Object} hsv - hsv object\n    * @return {Object} hsl object\n  */\n  public static hsvToHsl(hsv: HsvColor): HslColor {\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const l = (2 - s) * v;\n    const divisor = l <= 1 ? l : (2 - l);\n    // Avoid division by zero when lightness is close to zero\n    const saturation = divisor < 1e-9 ? 0 : (s * v) / divisor;\n    return {\n      h: hsv.h,\n      s: saturation * 100,\n      l: l * 50\n    };\n  }\n\n  /**\n    * @desc convert hsl object to hsv\n    * @param {Object} hsl - hsl object\n    * @return {Object} hsv object\n  */\n  public static hslToHsv(hsl: HslColor): HsvColor {\n    const l = hsl.l * 2;\n    const s = (hsl.s * ((l <= 100) ? l : 200 - l)) / 100;\n    // Avoid division by zero when l + s is near 0\n    const saturation = (l + s < 1e-9) ? 0 : (2 * s) / (l + s);\n    return {\n      h: hsl.h,\n      s: saturation * 100,\n      v: (l + s) / 2\n    };\n  }\n\n  public static kelvinToRgb(kelvin: number): RgbColor {\n    const temp = kelvin / 100;\n    let r,g,b;\n    if (temp < 66) {\n        r = 255\n        g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * Math.log(g)\n        b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * Math.log(b)\n    } else {\n        r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * Math.log(r)\n        g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * Math.log(g)\n        b = 255\n    }\n    return {r, g, b};\n  }\n\n  public static rgbToKelvin(rgb: RgbColor): number {\n    const { r, g, b } = rgb;\n    let minTemp = 1000;\n    let maxTemp = 40000;\n    const eps = 0.4;\n    let temp;\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      const rgb = IroColor.kelvinToRgb(temp);\n      if ((rgb.b / rgb.r) >= (b / r)) {\n          maxTemp = temp;\n      } else {\n          minTemp = temp;\n      }\n    }\n    return temp;\n  }\n\n  public get hsv() {\n    // _value is cloned to allow changes to be made to the values before passing them back\n    const value = this.value;\n    return {h: value.h, s: value.s, v: value.v};\n  }\n\n  public set hsv(newValue: any) {\n    const oldValue = this.value;\n\n    newValue = { ...oldValue, ...newValue };\n    // If this Color is being watched for changes we need to compare the new and old values to check the difference\n    // Otherwise we can just be lazy\n    if (this.onChange) {\n      // Compute changed values\n      let changes: ColorChanges = {\n        h: false,\n        v: false,\n        s: false,\n        a: false,\n      };\n\n      for (let key in oldValue) {\n        changes[key] = newValue[key] != oldValue[key]\n      };\n      // Update the old value\n      this.value = newValue;\n      // If the value has changed, call hook callback\n      if (changes.h || changes.s || changes.v || changes.a) this.onChange(this, changes);\n    } else {\n      this.value = newValue;\n    }\n  }\n\n  public get rgb() {\n    const {r, g, b} = IroColor.hsvToRgb(this.value);\n    return {\n      r: Math.round(r),\n      g: Math.round(g),\n      b: Math.round(b),\n    };\n  }\n\n  public set rgb(value: any) {\n    this.hsv = {\n      ...IroColor.rgbToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get hsl() {\n    const {h, s, l} = IroColor.hsvToHsl(this.value);\n    return {\n      h: Math.round(h),\n      s: Math.round(s),\n      l: Math.round(l),\n    };\n  }\n\n  public set hsl(value: any) {\n    this.hsv = {\n      ...IroColor.hslToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get kelvin() {\n    return IroColor.rgbToKelvin(this.rgb);\n  }\n\n  public set kelvin(value: number) {\n    this.rgb = IroColor.kelvinToRgb(value);\n  }\n\n  public get rgbString() {\n    const rgb = this.rgb;\n    return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n  }\n\n  public set rgbString(value: string) {\n    let match;\n    let r, g, b, a = 1;\n    if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n    }\n    else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a};\n    } \n    else {\n      throw new Error('invalid rgb string');\n    }\n  }\n\n  public get hexString() {\n    const rgb = this.rgb;\n    return `#${ intToHex(rgb.r) }${ intToHex(rgb.g) }${ intToHex(rgb.b) }`;\n  }\n\n  public set hexString(value: string) {\n    let match;\n    let r, g, b, a = 255;\n    if (match = REGEX_HEX_3.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n    }\n    else if (match = REGEX_HEX_4.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n      a = parseHexInt(match[4]) * 17;\n    }\n    else if (match = REGEX_HEX_6.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n    }\n    else if (match = REGEX_HEX_8.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n      a = parseHexInt(match[4]);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a: a / 255};\n    }\n    else {\n      throw new Error('invalid hex string');\n    }\n  }\n\n  public get hslString() {\n    const hsl = this.hsl;\n    return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;\n  }\n\n  public set hslString(value: string) {\n    let match;\n    let h, s, l, a = 1;\n    if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n    }\n    else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.hsl = {h, s, l, a};\n    } \n    else {\n      throw new Error('invalid hsl string');\n    }\n  }\n}","import { IroColor } from './color';\n\nexport function getSliderDimensions(props: any) {\n  let { width, sliderHeight, borderWidth, handleRadius, padding } = props;\n  sliderHeight = sliderHeight ? sliderHeight : padding * 2 + handleRadius * 2 + borderWidth * 2;\n  return {\n    radius: sliderHeight / 2,\n    x: 0,\n    y: 0,\n    width: width,\n    height: sliderHeight,\n  }\n}\n\nexport function getCurrentSliderValue(props: any) {\n  const hsv = props.color.hsv;\n  switch (props.sliderType) {\n    case 'hue':\n      return hsv.h /= 3.6;\n    case 'saturation':\n      return hsv.s;\n    case 'value':\n    default:\n      return hsv.v;\n  }\n}\n\nexport function getSliderValueFromInput(props: any, x: number, y: number, bounds) {\n  const handleRange = bounds.width - bounds.height;\n  const cornerRadius = bounds.height / 2;\n  let dist = x - (bounds.left + cornerRadius);\n  dist = Math.max(Math.min(dist, handleRange), 0);\n  const percent = Math.round((100 / handleRange) * dist);\n  switch (props.sliderType) {\n    case 'hue':\n      return percent * 3.6;\n    default:\n      return percent;\n  }\n}\n\nexport function getSliderHandlePosition(props: any) {\n  const { width, height, radius } = getSliderDimensions(props);\n  const sliderValue = getCurrentSliderValue(props);\n  const handleRange = width - radius * 2;\n  const x = radius + (sliderValue / 100) * handleRange;\n  const y = height / 2;\n  return {x, y};\n}\n\nexport function getSliderGradient(props: any) {\n  const hsv = props.color.hsv;\n\n  switch (props.sliderType) {\n    case 'kelvin':\n      const stops = [];\n      const min = 3000;\n      const max = 9000;\n      const numStops = 12;\n      const range = max - min;\n      for (let kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {\n        const { r, g, b } = IroColor.kelvinToRgb(kelvin);\n        stops.push([ 100 / numStops * stop, `rgb(${r},${g},${b})` ]);\n      }\n      return stops;\n    case 'hue':\n      return [\n        [0,      '#f00'],\n        [16.666, '#ff0'],\n        [33.333, '#0f0'],\n        [50,     '#0ff'],\n        [66.666, '#00f'],\n        [83.333, '#f0f'],\n        [100,    '#f00'],\n      ];\n    case 'saturation':\n      const noSat = IroColor.hsvToHsl({h: hsv.h, s: 0, v: hsv.v});\n      const fullSat = IroColor.hsvToHsl({h: hsv.h, s: 100, v: hsv.v});\n      return [\n        [0, `hsl(${noSat.h}, ${noSat.s}%, ${noSat.l}%)`],\n        [100, `hsl(${fullSat.h}, ${fullSat.s}%, ${fullSat.l}%)`]\n      ];\n    case 'value':\n    default:\n      const hsl = IroColor.hsvToHsl({h: hsv.h, s: hsv.s, v: 100});\n      return [\n        [0, '#000'],\n        [100, `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`]\n      ];\n  }\n}","export function translateWheelAngle(props: any, angle: number) {\n  const wheelAngle = props.wheelAngle;\n    if (props.wheelDirection === 'clockwise') {\n      angle = -360 + angle - wheelAngle;\n    } else {\n      angle = wheelAngle - angle\n    }\n    // javascript's modulo operator doesn't produce positive numbers with negative input\n    // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n    return (angle % 360 + 360) % 360;\n}\n\nexport function getWheelCenter(props: any) {\n  const dist = (props.width / 2);\n  return {\n    x: dist,\n    y: dist\n  };\n}\n\nexport function getWheelHandlePosition(props: any) {\n  const hsv = props.color.hsv;\n  const { width, borderWidth, padding, handleRadius, wheelDirection } = props;\n  const radius = width / 2 - borderWidth;\n  const center = getWheelCenter(props);\n  const handleAngle = translateWheelAngle(props, hsv.h) * (Math.PI / 180);\n  const handleRange = radius - padding - handleRadius - borderWidth;\n  const handleDist = (hsv.s / 100) * handleRange;\n  const direction = wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: center.x + handleDist * Math.cos(handleAngle) * direction,\n    y: center.y + handleDist * Math.sin(handleAngle) * direction,\n  }\n}\n\nexport function getWheelValueFromInput(props: any, x: number, y: number, bounds) {\n  const { left, top } = bounds;\n  const radius = props.width / 2;\n  const handleRange = (radius - props.padding - props.handleRadius - props.borderWidth);\n  const cX = radius;\n  const cY = radius;\n  x = cX - (x - left);\n  y = cY - (y - top);\n  const handleAngle = Math.atan2(y, x);\n  // Calculate the hue by converting the angle to radians\n  const hue = translateWheelAngle(props, Math.round(handleAngle * (180 / Math.PI)) + 180);\n  // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n  const handleDist = Math.min(Math.sqrt(x * x + y * y), handleRange);\n  return {\n    h: hue,\n    s: Math.round((100 / handleRange) * handleDist)\n  };\n}","/**\n * Resolve an SVG URL\n * This is required to work around how Safari handles gradient URLS under certain conditions\n * If a page is using a client-side routing library which makes use of the HTML <base> tag, \n * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)\n * More info on the problem: \n * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427\n * https://github.com/jaames/iro.js/issues/18\n * https://github.com/jaames/iro.js/issues/45\n */\nexport function resolveSvgUrl(url) {\n  // Sniff useragent string to check if the user is running Safari\n  const ua = window.navigator.userAgent;\n  const isSafari = /^((?!chrome|android).)*safari/i.test(ua);\n  const isIos = /iPhone|iPod|iPad/i.test(ua);\n  const location = window.location;\n  return (isSafari || isIos) ? `${location.protocol}//${location.host}${location.pathname}${location.search}${url}` : url;\n}\n\n/**\n * Get the path commands to draw an svg arc\n */\nexport function getSvgArcPath(cx: number, cy: number, radius: number, startAngle: number, endAngle: number) {\n  const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n  startAngle *= Math.PI / 180;\n  endAngle *= Math.PI / 180;\n  const x1 = cx + radius * Math.cos(endAngle);\n  const y1 = cy + radius * Math.sin(endAngle);\n  const x2 = cx + radius * Math.cos(startAngle);\n  const y2 = cy + radius * Math.sin(startAngle);\n  return `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${x2} ${y2}`;\n}","import { IroColor, IroColorValue } from './color';\n\nexport interface IroHandleOrigin {\n  x: number;\n  y: number;\n}\n\nexport interface IroColorPickerOptions {\n  width?: number;\n  height?: number;\n  handleRadius?: number;\n  handleSvg?: string;\n  handleOrigin?: IroHandleOrigin;\n  color?: IroColorValue;\n  borderColor?: string;\n  borderWidth?: number;\n  wheelLightness?: boolean;\n  wheelAngle?: number;\n  wheelDirection?: string;\n  sliderHeight?: number;\n  sliderMargin?: number;\n  padding?: number;\n}\n\nexport const iroColorPickerOptionDefaults: IroColorPickerOptions = {\n  width: 300,\n  height: 300,\n  handleRadius: 8,\n  handleSvg: null,\n  handleOrigin: {x: 0, y: 0},\n  color: '#fff',\n  borderColor: '#fff',\n  borderWidth: 0,\n  wheelLightness: true,\n  wheelAngle: 0,\n  wheelDirection: 'anticlockwise',\n  sliderHeight: null,\n  sliderMargin: 12,\n  padding: 6,\n}"],"names":["const","CSS_UNIT","PERMISSIVE_MATCH_3","PERMISSIVE_MATCH_4","REGEX_FUNCTIONAL_RGB","RegExp","REGEX_FUNCTIONAL_RGBA","REGEX_FUNCTIONAL_HSL","REGEX_FUNCTIONAL_HSLA","REGEX_HEX_3","REGEX_HEX_4","REGEX_HEX_6","REGEX_HEX_8","parseUnit","str","max","isPercentage","indexOf","num","parseFloat","parseHexInt","parseInt","intToHex","int","toString","padStart","IroColor","constructor","value","onChange","this","set","getSliderDimensions","props","radius","sliderHeight","x","y","width","height","getCurrentSliderValue","hsv","color","sliderType","h","s","v","translateWheelAngle","angle","wheelAngle","wheelDirection","getWheelCenter","dist","test","hexString","rgbString","hslString","rgb","Error","hsl","setChannel","format","channel","Object","clone","hsvToRgb","i","Math","floor","f","p","q","t","mod","r","g","b","rgbToHsv","min","delta","hue","saturation","hsvToHsl","l","divisor","hslToHsv","kelvinToRgb","kelvin","temp","log","rgbToKelvin","minTemp","maxTemp","prototypeAccessors","newValue","oldValue","changes","let","key","a","round","undefined","match","exec","bounds","handleRange","left","percent","stops","stop","range","push","noSat","fullSat","borderWidth","center","handleAngle","PI","handleDist","padding","handleRadius","direction","cos","sin","atan2","sqrt","url","ua","window","navigator","userAgent","isSafari","isIos","location","cx","cy","startAngle","endAngle","largeArcFlag","handleSvg","handleOrigin","borderColor","wheelLightness","sliderMargin"],"mappings":"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"}