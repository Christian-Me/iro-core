{"version":3,"file":"iro-core.js","sources":["../src/color.ts","../src/slider.ts","../src/wheel.ts","../src/box.ts","../src/svg.ts","../src/colorPickerOptions.ts"],"sourcesContent":["// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor\n// https://github.com/bgrins/TinyColor\n// Kelvin temperature math borrowed from Neil Barlett's implementation\n// from https://github.com/neilbartlett/color-temperature\n\n// https://www.w3.org/TR/css3-values/#integers\nconst CSS_INTEGER = '[-\\\\+]?\\\\d+%?';\n// http://www.w3.org/TR/css3-values/#number-value\nconst CSS_NUMBER = '[-\\\\+]?\\\\d*\\\\.\\\\d+%?';\n// Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome\nconst CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';\n\n// Parse function params\n// Parens and commas are optional, and this also allows for whitespace between numbers\nconst PERMISSIVE_MATCH_3 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\nconst PERMISSIVE_MATCH_4 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\n\n// Regex patterns for functional color strings\nconst REGEX_FUNCTIONAL_RGB = new RegExp('rgb' + PERMISSIVE_MATCH_3);\nconst REGEX_FUNCTIONAL_RGBA = new RegExp('rgba' + PERMISSIVE_MATCH_4);\nconst REGEX_FUNCTIONAL_HSL = new RegExp('hsl' + PERMISSIVE_MATCH_3);\nconst REGEX_FUNCTIONAL_HSLA = new RegExp('hsla' + PERMISSIVE_MATCH_4);\n\n// Color string parsing regex\nconst HEX_START = '^(?:#?|0x?)';\nconst HEX_INT_SINGLE = '([0-9a-fA-F]{1})';\nconst HEX_INT_DOUBLE = '([0-9a-fA-F]{2})';\nconst REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nconst REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nconst REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\nconst REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\n\n// Kelvin temperature bounds\nconst KELVIN_MIN = 1000;\nconst KELVIN_MAX = 40000;\n\n// Math shorthands\nconst { log, round, floor } = Math;\n\n/**\n * @desc Parse a css unit string - either regular int or a percentage number\n * @param str - css unit string\n * @param max - max unit value, used for calculating percentages\n */\nfunction parseUnit(str: string, max: number): number {\n  const isPercentage = str.indexOf('%') > -1;\n  const num = parseFloat(str);\n  return isPercentage ? (max / 100) * num : num;\n}\n\n/**\n * @desc Parse hex str to an int\n * @param str - hex string to parse\n */\nfunction parseHexInt(str: string): number {\n  return parseInt(str, 16);\n}\n\n/**\n * @desc Convert nunber into to 2-digit hex\n * @param int - number to convert\n */\nfunction intToHex(int: number): string {\n  return int.toString(16).padStart(2, '0');\n}\n\ninterface ColorChanges {\n  h: boolean;\n  s: boolean;\n  v: boolean;\n  a: boolean;\n}\n\n// all hsv color channels are optional by design\ninterface HsvColor {\n  h?: number;\n  s?: number;\n  v?: number;\n  a?: number;\n}\n\ninterface RgbColor {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\ninterface HslColor {\n  h: number;\n  s: number;\n  l: number;\n  a?: number;\n}\n\nexport type IroColorValue = IroColor | HsvColor | RgbColor | HslColor | string;\n\nexport class IroColor {\n  // internal color value storage\n  private $: HsvColor;\n  private onChange: Function;\n  /**\n    * @constructor Color object\n    * @param value - initial color value\n  */\n  constructor(value?: IroColorValue, onChange?: Function) {\n    // The default Color value\n    this.$ = {h: 0, s: 0, v: 0, a: 1};\n    if (value) this.set(value);\n    // The watch callback function for this Color will be stored here\n    this.onChange = onChange;\n  }\n\n  /**\n    * @desc Set the Color from any valid value\n    * @param value - new color value\n  */\n  public set(value: IroColorValue) {\n    if (typeof value === 'string') {\n      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value as string)) {\n        this.hexString = value as string;\n      }\n      else if (/^rgba?/.test(value as string)) {\n        this.rgbString = value as string;\n      }\n      else if (/^hsla?/.test(value as string)) {\n        this.hslString = value as string;\n      }\n    }\n    else if (typeof value === 'object') {\n      if (value instanceof IroColor) {\n        this.hsv = value.hsv;\n      }\n      else if (typeof value === 'object' && ('r' in value) && ('g' in value) && ('b' in value)) {\n        this.rgb = value;\n      }\n      else if (typeof value === 'object' && ('h' in value) && ('s' in value) && ('v' in value)) {\n        this.hsv = value;\n      }\n      else if (typeof value === 'object' && ('h' in value) && ('s' in value) && ('l' in value)) {\n        this.hsl = value;\n      }\n    }\n    else {\n      throw new Error('Invalid color value');\n    }\n  }\n\n  /**\n    * @desc Shortcut to set a specific channel value\n    * @param format - hsv | hsl | rgb\n    * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l\n    * @param value - new value for the channel\n  */\n  public setChannel(format: string, channel: string, value: number) {\n    this[format] = {...this[format], [channel]: value};\n  }\n\n  /**\n    * @desc make new Color instance with the same value as this one\n  */\n  public clone() {\n    return new IroColor(this);\n  }\n\n  /**\n    * @desc Convert hsv object to rgb\n    * @param hsv - hsv color object\n  */\n  public static hsvToRgb(hsv: HsvColor): RgbColor {\n    const h = hsv.h / 60;\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const i = floor(h);\n    const f = h - i;\n    const p = v * (1 - s);\n    const q = v * (1 - f * s);\n    const t = v * (1 - (1 - f) * s);\n    const mod = i % 6;\n    const r = [v, q, p, p, t, v][mod];\n    const g = [t, v, v, q, p, p][mod];\n    const b = [p, p, t, v, v, q][mod];\n    return {\n      r: r * 255, \n      g: g * 255, \n      b: b * 255\n    };\n  }\n\n  /**\n    * @desc Convert rgb object to hsv\n    * @param rgb - rgb object\n  */\n  public static rgbToHsv(rgb: RgbColor): HsvColor {\n    const r = rgb.r / 255;\n    const g = rgb.g / 255;\n    const b = rgb.b / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const delta = max - min;\n    let hue = 0;\n    let value = max;\n    let saturation = max === 0 ? 0 : delta / max;\n    switch (max) {\n      case min: \n        hue = 0; // achromatic\n        break;\n      case r: \n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g: \n        hue = (b - r) / delta + 2;\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n    return {\n      h: hue * 60,\n      s: saturation * 100,\n      v: value * 100\n    }\n  }\n\n  /**\n    * @desc Convert hsv object to hsl\n    * @param hsv - hsv object\n  */\n  public static hsvToHsl(hsv: HsvColor): HslColor {\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const l = (2 - s) * v;\n    const divisor = l <= 1 ? l : (2 - l);\n    // Avoid division by zero when lightness is close to zero\n    const saturation = divisor < 1e-9 ? 0 : (s * v) / divisor;\n    return {\n      h: hsv.h,\n      s: saturation * 100,\n      l: l * 50\n    };\n  }\n\n  /**\n    * @desc Convert hsl object to hsv\n    * @param hsl - hsl object\n  */\n  public static hslToHsv(hsl: HslColor): HsvColor {\n    const l = hsl.l * 2;\n    const s = (hsl.s * ((l <= 100) ? l : 200 - l)) / 100;\n    // Avoid division by zero when l + s is near 0\n    const saturation = (l + s < 1e-9) ? 0 : (2 * s) / (l + s);\n    return {\n      h: hsl.h,\n      s: saturation * 100,\n      v: (l + s) / 2\n    };\n  }\n\n  /**\n    * @desc Convert a kelvin temperature to an approx, RGB value\n    * @param kelvin - kelvin temperature\n  */\n  public static kelvinToRgb(kelvin: number): RgbColor {\n    const temp = kelvin / 100;\n    let r, g, b;\n    if (temp < 66) {\n      r = 255\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g)\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b)\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r)\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g)\n      b = 255\n    }\n    return {r: floor(r), g: floor(g), b: floor(b)};\n  }\n\n   /**\n    * @desc Convert an RGB color to an approximate kelvin temperature\n    * @param kelvin - kelvin temperature\n  */\n  public static rgbToKelvin(rgb: RgbColor): number {\n    const { r, g, b } = rgb;\n    const eps = 0.4;\n    let minTemp = KELVIN_MIN;\n    let maxTemp = KELVIN_MAX;\n    let temp;\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      const rgb = IroColor.kelvinToRgb(temp);\n      if ((rgb.b / rgb.r) >= (b / r)) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n    return temp;\n  }\n\n  public get hsv(): HsvColor {\n    // value is cloned to allow changes to be made to the values before passing them back\n    const value = this.$;\n    return {h: value.h, s: value.s, v: value.v};\n  }\n\n  public set hsv(newValue: HsvColor) {\n    const oldValue = this.$;\n\n    newValue = { ...oldValue, ...newValue };\n    // If this Color is being watched for changes we need to compare the new and old values to check the difference\n    // Otherwise we can just be lazy\n    if (this.onChange) {\n      // Compute changed values\n      let changes: ColorChanges = {\n        h: false,\n        v: false,\n        s: false,\n        a: false,\n      };\n\n      for (let key in oldValue) {\n        changes[key] = newValue[key] != oldValue[key]\n      };\n      // Update the old value\n      this.$ = newValue;\n      // If the value has changed, call hook callback\n      if (changes.h || changes.s || changes.v || changes.a) this.onChange(this, changes);\n    } else {\n      this.$ = newValue;\n    }\n  }\n\n  public get hsva(): HsvColor {\n    return {...this.$};\n  }\n\n  public set hsva(value: HsvColor) {\n    this.hsv = value;\n  }\n\n  public get hue(): number {\n    return this.$.h;\n  }\n\n  public set hue(value: number) {\n    this.hsv = { h: value };\n  }\n\n  public get saturation(): number {\n    return this.$.s;\n  }\n\n  public set saturation(value: number) {\n    this.hsv = { s: value };\n  }\n\n  public get value(): number {\n    return this.$.v;\n  }\n\n  public set value(value: number) {\n    this.hsv = { v: value };\n  }\n\n  public get alpha(): number {\n    return this.$.a;\n  }\n\n  public set alpha(value: number) {\n    this.hsv = { ...this.hsv, a: value };\n  }\n\n  public get kelvin(): number {\n    return IroColor.rgbToKelvin(this.rgb);\n  }\n\n  public set kelvin(value: number) {\n    this.rgb = IroColor.kelvinToRgb(value);\n  }\n\n  public get rgb(): RgbColor {\n    const {r, g, b} = IroColor.hsvToRgb(this.$);\n    return {\n      r: round(r),\n      g: round(g),\n      b: round(b),\n    };\n  }\n\n  public set rgb(value: RgbColor) {\n    this.hsv = {\n      ...IroColor.rgbToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get rgba(): RgbColor {\n    return { ...this.rgb, a: this.alpha };\n  }\n\n  public set rgba(value: RgbColor) {\n    this.rgb = value;\n  }\n\n  public get hsl(): HslColor {\n    const {h, s, l} = IroColor.hsvToHsl(this.$);\n    return {\n      h: round(h),\n      s: round(s),\n      l: round(l),\n    };\n  }\n\n  public set hsl(value: HslColor) {\n    this.hsv = {\n      ...IroColor.hslToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get hsla(): HslColor {\n    return { ...this.hsl, a: this.alpha };\n  }\n\n  public set hsla(value: HslColor) {\n    this.hsl = value;\n  }\n\n  public get rgbString(): string {\n    const rgb = this.rgb;\n    return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n  }\n\n  public set rgbString(value: string) {\n    let match;\n    let r, g, b, a = 1;\n    if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n    }\n    else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a};\n    } \n    else {\n      throw new Error('Invalid rgb string');\n    }\n  }\n\n  public get rgbaString(): string {\n    const rgba = this.rgba;\n    return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\n  }\n\n  public set rgbaString(value: string) {\n    this.rgbString = value;\n  }\n\n  public get hexString(): string {\n    const rgb = this.rgb;\n    return `#${ intToHex(rgb.r) }${ intToHex(rgb.g) }${ intToHex(rgb.b) }`;\n  }\n\n  public set hexString(value: string) {\n    let match;\n    let r, g, b, a = 255;\n    if (match = REGEX_HEX_3.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n    }\n    else if (match = REGEX_HEX_4.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n      a = parseHexInt(match[4]) * 17;\n    }\n    else if (match = REGEX_HEX_6.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n    }\n    else if (match = REGEX_HEX_8.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n      a = parseHexInt(match[4]);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a: a / 255};\n    }\n    else {\n      throw new Error('Invalid hex string');\n    }\n  }\n\n  public get hex8String(): string {\n    const rgba = this.rgba;\n    return `#${intToHex(rgba.r)}${intToHex(rgba.g)}${intToHex(rgba.b)}${intToHex(floor(rgba.a * 255))}`;\n  }\n\n  public set hex8String(value: string) {\n    this.hexString = value;\n  }\n\n  public get hslString(): string {\n    const hsl = this.hsl;\n    return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;\n  }\n\n  public set hslString(value: string) {\n    let match;\n    let h, s, l, a = 1;\n    if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n    }\n    else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.hsl = {h, s, l, a};\n    } \n    else {\n      throw new Error('Invalid hsl string');\n    }\n  }\n\n  public get hslaString(): string {\n    const hsla = this.hsla;\n    return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;\n  }\n\n  public set hslaString(value: string) {\n    this.hslString = value;\n  }\n}","import { IroColor } from './color';\nimport { IroColorPickerOptions } from './colorPickerOptions';\n\nexport type SliderShape = 'bar' | 'circle' | '';\nexport type SliderType = 'hue' | 'saturation' | 'value' | 'alpha' | 'kelvin' | '';\n\nexport interface SliderOptions extends IroColorPickerOptions {\n  color: IroColor;\n  sliderShape: SliderShape;\n  sliderType: SliderType;\n  minTemperature: number;\n  maxTemperature: number;\n}\n\nexport const sliderDefaultOptions = {\n  sliderShape: 'bar',\n  sliderType: 'value',\n  minTemperature: 2200,\n  maxTemperature: 11000\n}\n\n/**\n * @desc Get the CSS styles for the slider root\n * @param props - slider props\n */\nexport function getSliderStyles(props: Partial<SliderOptions>) {\n  return {\n    [props.layoutDirection === 'horizontal' ? 'marginLeft' : 'marginTop']: props.sliderMargin\n  }\n}\n\n/**\n * @desc Get the bounding dimensions of the slider\n * @param props - slider props\n */\nexport function getSliderDimensions(props: Partial<SliderOptions>) {\n  let { width, sliderSize: sliderSize, borderWidth, handleRadius, padding, sliderShape } = props;\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  // automatically calculate sliderSize if its not defined\n  sliderSize = sliderSize ? sliderSize : padding * 2 + handleRadius * 2 + borderWidth * 2;\n  if (sliderShape === 'circle') {\n    return {\n      handleStart: props.padding + props.handleRadius,\n      handleRange: width - padding * 2 - handleRadius * 2 - borderWidth * 2,\n      width: width,\n      height: width,\n      cx: width / 2,\n      cy: width / 2,\n      radius: width / 2 - borderWidth / 2\n    }\n  } else {\n    return {\n      handleStart: sliderSize / 2,\n      handleRange: width - sliderSize,\n      radius: sliderSize / 2,\n      x: 0,\n      y: 0,\n      width: ishorizontal ? sliderSize : width,\n      height: ishorizontal ? width : sliderSize,\n    }\n  }\n}\n\n/**\n * @desc Get the current slider value as a percentage\n * @param props - slider props\n */\nexport function getCurrentSliderValue(props: Partial<SliderOptions>) {\n  const hsva = props.color.hsva;\n  switch (props.sliderType) {\n    case 'alpha':\n      return hsva.a * 100;\n    case 'kelvin':\n      const { minTemperature, maxTemperature } = props;\n      const temperatureRange = maxTemperature - minTemperature;\n      const percent = ((props.color.kelvin - minTemperature) / temperatureRange) * 100;\n      // clmap percentage\n      return Math.max(0, Math.min(percent, 100));\n    case 'hue':\n      return hsva.h /= 3.6;\n    case 'saturation':\n      return hsva.s;\n    case 'value':\n    default:\n      return hsva.v;\n  }\n}\n\n/**\n * @desc Get the current slider value from user input\n * @param props - slider props\n * @param x - global input x position\n * @param y - global input y position\n * @param bounds - slider element bounding box\n */\nexport function getSliderValueFromInput(props: Partial<SliderOptions>, x: number, y: number, bounds: any) {\n  const { handleRange, handleStart } = getSliderDimensions(props);\n  let handlePos;\n  if (props.layoutDirection === 'horizontal') {\n    handlePos = -1 * (y - bounds.top) + handleRange + handleStart;\n  } else {\n    handlePos = x - (bounds.left + handleStart);\n  }\n  // clamp handle position\n  handlePos = Math.max(Math.min(handlePos, handleRange), 0);\n  const percent = Math.round((100 / handleRange) * handlePos);\n  switch (props.sliderType) {\n    case 'kelvin':\n      const { minTemperature, maxTemperature } = props;\n      const temperatureRange = maxTemperature - minTemperature;\n      return minTemperature + temperatureRange * (percent / 100);\n    case 'alpha':\n      return percent / 100;\n    case 'hue':\n      return percent * 3.6;\n    default:\n      return percent;\n  }\n}\n\n/**\n * @desc Get the current slider position\n * @param props - slider props\n */\nexport function getSliderHandlePosition(props: Partial<SliderOptions>) {\n  const { width, height, handleRange, handleStart } = getSliderDimensions(props);\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  const sliderValue = getCurrentSliderValue(props);\n  const midPoint = ishorizontal ? width / 2 : height / 2;\n  let handlePos = handleStart + (sliderValue / 100) * handleRange;\n  if (ishorizontal) {\n    handlePos = -1 * handlePos + handleRange + handleStart * 2;\n  } \n  return {x: ishorizontal ? midPoint : handlePos, y: ishorizontal ? handlePos : midPoint};\n}\n\n/**\n * @desc Get the gradient stops for a slider\n * @param props - slider props\n */\nexport function getSliderGradient(props: Partial<SliderOptions>) {\n  const hsv = props.color.hsv;\n\n  switch (props.sliderType) {\n    case 'alpha':\n      const rgb = props.color.rgb;\n      return [\n        [0, `rgba(${ rgb.r },${ rgb.g },${ rgb.b },0)`],\n        [100, `rgb(${ rgb.r },${ rgb.g },${ rgb.b })`],\n      ]\n    case 'kelvin':\n      const stops = [];\n      const min = props.minTemperature;\n      const max = props.maxTemperature;\n      const numStops = 8;\n      const range = max - min;\n      for (let kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {\n        const { r, g, b } = IroColor.kelvinToRgb(kelvin);\n        stops.push([ 100 / numStops * stop, `rgb(${r},${g},${b})` ]);\n      }\n      return stops;\n    case 'hue':\n      return [\n        [0,      '#f00'],\n        [16.666, '#ff0'],\n        [33.333, '#0f0'],\n        [50,     '#0ff'],\n        [66.666, '#00f'],\n        [83.333, '#f0f'],\n        [100,    '#f00'],\n      ];\n    case 'saturation':\n      const noSat = IroColor.hsvToHsl({h: hsv.h, s: 0, v: hsv.v});\n      const fullSat = IroColor.hsvToHsl({h: hsv.h, s: 100, v: hsv.v});\n      return [\n        [0, `hsl(${noSat.h},${noSat.s}%,${noSat.l}%)`],\n        [100, `hsl(${fullSat.h},${fullSat.s}%,${fullSat.l}%)`]\n      ];\n    case 'value':\n    default:\n      const hsl = IroColor.hsvToHsl({h: hsv.h, s: hsv.s, v: 100});\n      return [\n        [0, '#000'],\n        [100, `hsl(${hsl.h},${hsl.s}%,${hsl.l}%)`]\n      ];\n  }\n}\n\n/**\n * @desc Get the gradient coords for a slider\n * @param props - slider props\n */\nexport function getSliderGradientCoords(props: Partial<SliderOptions>) {\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  return {\n    x1: '0%',\n    y1: ishorizontal ? '100%' : '0%',\n    x2: ishorizontal ? '0%' : '100%',\n    y2: '0%'\n  }\n}","import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor } from './color';\n\nexport interface WheelProps extends IroColorPickerOptions {\n  color: IroColor;\n}\n\n/**\n * @desc Get the point as the center of the wheel\n * @param props - wheel props\n */\nexport function getWheelDimensions(props: Partial<WheelProps>) {\n  const rad = props.width / 2;\n  return {\n    width: props.width,\n    radius: rad - props.borderWidth,\n    cx: rad,\n    cy: rad\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateWheelAngle(props: Partial<WheelProps>, angle: number) {\n  const wheelAngle = props.wheelAngle;\n  if (props.wheelDirection === 'clockwise') {\n    angle = -360 + angle - wheelAngle;\n  } else {\n    angle = wheelAngle - angle\n  }\n  // javascript's modulo operator doesn't produce positive numbers with negative input\n  // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n  return (angle % 360 + 360) % 360;\n}\n\n/**\n * @desc Get the current handle position\n * @param props - wheel props\n */\nexport function getWheelHandlePosition(props: Partial<WheelProps>) {\n  const hsv = props.color.hsv;\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n  const handleAngle = translateWheelAngle(props, hsv.h) * (Math.PI / 180);\n  const handleDist = (hsv.s / 100) * handleRange;\n  const direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction,\n  }\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n * @param bounds - wheel element bounding box\n */\nexport function getWheelValueFromInput(props: Partial<WheelProps>, x: number, y: number, bounds: any) {\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n  x = cx - (x - bounds.left);\n  y = cy - (y - bounds.top);\n  // Calculate the hue by converting the angle to radians\n  const hue = translateWheelAngle(props, Math.atan2(-y, -x) * (180 / Math.PI));\n  // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n  const handleDist = Math.min(Math.sqrt(x * x + y * y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round((100 / handleRange) * handleDist)\n  };\n}","import { IroColor } from './color';\nimport { IroColorPickerOptions } from './colorPickerOptions';\n\nexport interface BoxOptions extends IroColorPickerOptions {\n  color: IroColor;\n}\n\n/**\n * @desc Get the CSS styles for the box root element\n * @param props - box props\n */\nexport function getBoxStyles(props: Partial<BoxOptions>) {\n  return {\n    [props.layoutDirection === 'horizontal' ? 'marginLeft' : 'marginTop']: props.sliderMargin\n  }\n}\n\n/**\n * @desc Get the bounding dimensions of the box\n * @param props - box props\n */\nexport function getBoxDimensions(props: Partial<BoxOptions>) {\n  const { width, padding, handleRadius } = props;\n  return {\n    width: width,\n    height: width,\n    radius: padding + handleRadius\n  };\n}\n\n/**\n * @desc Get the current box value from user input\n * @param props - box props\n * @param x - global input x position\n * @param y - global input y position\n * @param bounds - box element bounding box\n */\nexport function getBoxValueFromInput(props: Partial<BoxOptions>, x: number, y: number, bounds: any) {\n  const { width, height, radius } = getBoxDimensions(props);\n  const handleStart = radius;\n  const handleRangeX = width - radius * 2;\n  const handleRangeY = height - radius * 2;\n  x -= (bounds.left + handleStart);\n  y -= (bounds.top + handleStart);\n  const percentX = (x / handleRangeX) * 100;\n  const percentY = (y / handleRangeY) * 100;\n  return {\n    s: Math.max(0, Math.min(percentX, 100)),\n    v: Math.max(0, Math.min(100 - percentY, 100))\n  }\n}\n\n/**\n * @desc Get the current box handle position\n * @param props - box props\n */\nexport function getBoxHandlePosition(props: Partial<BoxOptions>) {\n  const { width, height, radius } = getBoxDimensions(props);\n  const hsv = props.color.hsv;\n  const handleStart = radius;\n  const handleRangeX = width - radius * 2;\n  const handleRangeY = height - radius * 2;\n  return { \n    x: handleStart + (hsv.s / 100) * handleRangeX,\n    y: handleStart + (handleRangeY - ((hsv.v / 100) * handleRangeY))\n  }\n}\n\n/**\n * @desc Get the gradient stops for a box\n * @param props - box props\n */\nexport function getBoxGradients(props: Partial<BoxOptions>) {\n  const hue = props.color.hue;\n  return [\n    // saturation gradient\n    [\n      [0, '#fff'],\n      [100, `hsl(${hue},100%,50%)`],\n    ],\n    // lightness gradient\n    [\n      [0, 'rgba(0,0,0,0)'],\n      [100, '#000'],\n    ]\n  ];\n}","// Keep track of html <base> elements for resolveSvgUrl\n// getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree\n// So it only needs to be called once\nconst BASE_ELEMENTS = document.getElementsByTagName('base');\n\n/**\n * @desc Resolve an SVG reference URL\n * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions\n * If a page is using a client-side routing library which makes use of the HTML <base> tag, \n * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)\n * More info on the problem: \n * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427\n * https://github.com/jaames/iro.js/issues/18\n * https://github.com/jaames/iro.js/issues/45\n * https://github.com/jaames/iro.js/pull/89\n * @props url - SVG reference URL\n */\nexport function resolveSvgUrl(url: string) {\n  // Sniff useragent string to check if the user is running Safari\n  const ua = window.navigator.userAgent;\n  const isSafari = /^((?!chrome|android).)*safari/i.test(ua);\n  const isIos = /iPhone|iPod|iPad/i.test(ua);\n  const location = window.location;\n  return ((isSafari || isIos) && (BASE_ELEMENTS.length > 0)) ? `${location.protocol}//${location.host}${location.pathname}${location.search}${url}` : url;\n}\n\n/**\n * @desc Get the path commands to draw an svg arc\n * @props cx - arc center point x\n * @props cy - arc center point y\n * @props radius - arc radius\n * @props startAngle - arc start angle\n * @props endAngle - arc end angle\n */\nexport function getSvgArcPath(cx: number, cy: number, radius: number, startAngle: number, endAngle: number) {\n  const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n  startAngle *= Math.PI / 180;\n  endAngle *= Math.PI / 180;\n  const x1 = cx + radius * Math.cos(endAngle);\n  const y1 = cy + radius * Math.sin(endAngle);\n  const x2 = cx + radius * Math.cos(startAngle);\n  const y2 = cy + radius * Math.sin(startAngle);\n  return `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${x2} ${y2}`;\n}","import { IroColor, IroColorValue } from './color';\n\nexport type LayoutDirection = 'vertical' | 'horizontal' | '';\n\nexport type WheelDirection = 'clockwise' | 'anticlockwise' | '';\n\nexport interface IroColorPickerOptions {\n  width?: number;\n  height?: number;\n  handleRadius?: number;\n  handleSvg?: string;\n  handleProps?: any;\n  color?: IroColorValue;\n  borderColor?: string;\n  borderWidth?: number;\n  wheelLightness?: boolean;\n  wheelAngle?: number;\n  wheelDirection?: WheelDirection;\n  layoutDirection?: LayoutDirection;\n  sliderSize?: number;\n  sliderMargin?: number;\n  padding?: number;\n}\n\nexport const iroColorPickerOptionDefaults: IroColorPickerOptions = {\n  width: 300,\n  height: 300,\n  handleRadius: 8,\n  handleSvg: null,\n  handleProps: {x: 0, y: 0},\n  color: '#fff',\n  borderColor: '#fff',\n  borderWidth: 0,\n  wheelLightness: true,\n  wheelAngle: 0,\n  wheelDirection: 'anticlockwise',\n  layoutDirection: 'vertical',\n  sliderSize: null,\n  sliderMargin: 12,\n  padding: 6,\n}"],"names":["const","CSS_UNIT","PERMISSIVE_MATCH_3","PERMISSIVE_MATCH_4","REGEX_FUNCTIONAL_RGB","RegExp","REGEX_FUNCTIONAL_RGBA","REGEX_FUNCTIONAL_HSL","REGEX_FUNCTIONAL_HSLA","REGEX_HEX_3","HEX_START","REGEX_HEX_4","REGEX_HEX_6","REGEX_HEX_8","parseUnit","str","max","isPercentage","indexOf","num","parseFloat","parseHexInt","parseInt","intToHex","int","toString","padStart","IroColor","constructor","value","onChange","$","this","set","getSliderDimensions","props","ishorizontal","layoutDirection","sliderSize","padding","handleRadius","borderWidth","handleStart","handleRange","width","height","cx","cy","radius","x","y","getCurrentSliderValue","hsva","color","sliderType","a","Math","min","kelvin","minTemperature","h","s","v","getWheelDimensions","rad","translateWheelAngle","angle","wheelAngle","wheelDirection","getBoxDimensions","test","hexString","rgbString","hslString","Error","hsv","rgb","hsl","setChannel","format","channel","Object","clone","hsvToRgb","i","floor","f","p","q","t","mod","r","g","b","rgbToHsv","delta","hue","saturation","hsvToHsl","l","divisor","hslToHsv","kelvinToRgb","temp","log","rgbToKelvin","minTemp","maxTemp","prototypeAccessors","newValue","oldValue","changes","let","key","alpha","round","undefined","rgba","hsla","match","exec","rgbaString","hex8String","hslaString","BASE_ELEMENTS","document","getElementsByTagName","sliderShape","maxTemperature","sliderMargin","bounds","handlePos","top","left","percent","midPoint","stops","range","stop","push","noSat","fullSat","x1","y1","x2","y2","handleAngle","PI","handleDist","direction","cos","sin","atan2","sqrt","percentY","handleRangeY","url","ua","window","navigator","userAgent","isSafari","isIos","location","length","startAngle","endAngle","largeArcFlag","handleSvg","handleProps","borderColor","wheelLightness"],"mappings":"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"}